{"dependencies":[{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1524411533120},{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1524411533119},{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524410852123},{"name":"../../environment","loc":{"line":3,"column":28}},{"name":"./tex_util","loc":{"line":4,"column":25}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = require(\"../../environment\");\nvar tex_util_1 = require(\"./tex_util\");\nvar TextureManager = (function () {\n    function TextureManager(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.allocatedTextures = [];\n        this.usedTextureCount = {};\n    }\n    TextureManager.prototype.acquireTexture = function (shapeRC, logicalTexType) {\n        var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType);\n        var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextureCount)) {\n            this.usedTextureCount[shapeKey] = 0;\n        }\n        this.usedTextureCount[shapeKey]++;\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this.log();\n            return this.freeTextures[shapeKey].shift();\n        }\n        this.numUsedTextures++;\n        this.log();\n        var newTexture;\n        if (physicalTexType === tex_util_1.PhysicalTextureType.FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === tex_util_1.PhysicalTextureType.FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === tex_util_1.PhysicalTextureType.UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.allocatedTextures.push(newTexture);\n        return newTexture;\n    };\n    TextureManager.prototype.releaseTexture = function (texture, shape, logicalTexType) {\n        var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType);\n        var shapeKey = getKeyFromTextureShape(shape, physicalTexType);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this.numUsedTextures--;\n        this.usedTextureCount[shapeKey]--;\n        this.log();\n    };\n    TextureManager.prototype.log = function () {\n        if (!this.logEnabled) {\n            return;\n        }\n        var total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + total + \")\");\n    };\n    TextureManager.prototype.getNumUsedTextures = function () {\n        return this.numUsedTextures;\n    };\n    TextureManager.prototype.getNumFreeTextures = function () {\n        return this.numFreeTextures;\n    };\n    TextureManager.prototype.dispose = function () {\n        var _this = this;\n        if (this.allocatedTextures == null) {\n            return;\n        }\n        this.allocatedTextures.forEach(function (texture) {\n            _this.gpgpu.deleteMatrixTexture(texture);\n        });\n        this.freeTextures = null;\n        this.allocatedTextures = null;\n        this.usedTextureCount = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n    };\n    return TextureManager;\n}());\nexports.TextureManager = TextureManager;\nfunction getPhysicalFromLogicalTextureType(logicalTexType) {\n    if (logicalTexType === tex_util_1.LogicalTextureType.UNSIGNED_BYTE) {\n        return tex_util_1.PhysicalTextureType.UNSIGNED_BYTE;\n    }\n    else if (logicalTexType === tex_util_1.LogicalTextureType.FLOAT_UPLOAD) {\n        return tex_util_1.PhysicalTextureType.FLOAT32;\n    }\n    else if (logicalTexType === tex_util_1.LogicalTextureType.FLOAT_RENDER) {\n        return environment_1.ENV.get('WEBGL_RENDER_FLOAT32_ENABLED') ?\n            tex_util_1.PhysicalTextureType.FLOAT32 :\n            tex_util_1.PhysicalTextureType.FLOAT16;\n    }\n    throw new Error(\"Unknown logical texture type \" + logicalTexType);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType) {\n    return shapeRowsCol[0] + \"_\" + shapeRowsCol[1] + \"_\" + physicalTexType;\n}\n","map":{"version":3,"file":"texture_manager.js","sourceRoot":"","sources":["../src/kernels/webgl/texture_manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENV} from '../../environment';\nimport {GPGPUContext} from './gpgpu_context';\nimport {LogicalTextureType, PhysicalTextureType} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private freeTextures: {[shape: string]: WebGLTexture[]} = {};\n  private logEnabled = false;\n  private allocatedTextures: WebGLTexture[] = [];\n  private usedTextureCount: {[shape: string]: number} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(shapeRC: [number, number], logicalTexType: LogicalTextureType):\n      WebGLTexture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextureCount)) {\n      this.usedTextureCount[shapeKey] = 0;\n    }\n    this.usedTextureCount[shapeKey]++;\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this.log();\n      return this.freeTextures[shapeKey].shift();\n    }\n    this.numUsedTextures++;\n    this.log();\n\n    let newTexture: WebGLTexture;\n    if (physicalTexType === PhysicalTextureType.FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n\n    } else if (physicalTexType === PhysicalTextureType.UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.allocatedTextures.push(newTexture);\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: WebGLTexture, shape: [number, number],\n      logicalTexType: LogicalTextureType): void {\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    this.freeTextures[shapeKey].push(texture);\n    this.numFreeTextures++;\n    this.numUsedTextures--;\n    this.usedTextureCount[shapeKey]--;\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.allocatedTextures == null) {\n      // Already disposed.\n      return;\n    }\n    this.allocatedTextures.forEach(texture => {\n      this.gpgpu.deleteMatrixTexture(texture);\n    });\n    this.freeTextures = null;\n    this.allocatedTextures = null;\n    this.usedTextureCount = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n  }\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType: LogicalTextureType):\n    PhysicalTextureType {\n  if (logicalTexType === LogicalTextureType.UNSIGNED_BYTE) {\n    return PhysicalTextureType.UNSIGNED_BYTE;\n  } else if (logicalTexType === LogicalTextureType.FLOAT_UPLOAD) {\n    return PhysicalTextureType.FLOAT32;\n  } else if (logicalTexType === LogicalTextureType.FLOAT_RENDER) {\n    return ENV.get('WEBGL_RENDER_FLOAT32_ENABLED') ?\n        PhysicalTextureType.FLOAT32 :\n        PhysicalTextureType.FLOAT16;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number],\n    physicalTexType: PhysicalTextureType): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}`;\n}\n"]}},"hash":"2ab0befe4875c5ce90b81954f49a44dc","cacheData":{"env":{}}}